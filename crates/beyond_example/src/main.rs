use std::process::ExitCode;

use serde::{Deserialize, Serialize};

// The structure of the data that will be sent to the server
// to process.
#[derive(Deserialize, Serialize)]
pub struct HelloRequest {
    pub name: String,
}

// The structure of the data that will be sent back from
// the server.
#[derive(Deserialize, Serialize)]
pub struct HelloResponse {
    pub message: String,
}

// The generated code should always be kept in a seperate module
// to prevent name collisions.
mod beyond_impl {
    use super::*;

    // The `Server` struct will contain the server-side implementations of all routes.
    #[derive(beyond::Beyond)]
    #[beyond_route(hello HelloRequest HelloResponse)] // Because proc macros cannot access impl blocks, each route needs to be specified here.
    pub struct Server;

    impl Server {
        // The implementation of the `hello` route defined using the attribute on the `Server` struct.
        // It takes the request as an argument and returns a response.
        // Note that the request and response both have to implement
        // `serde::Deserialize` and `serde::Serialize`.
        // This one generates a message that includes the hostname of
        // the device it is run on to show the `beyond`'s functionality.
        pub fn hello(&self, request: HelloRequest) -> HelloResponse {
            let hostname = String::from_utf8_lossy(
                &std::process::Command::new("hostname")
                    .output()
                    .unwrap()
                    .stdout,
            )
            .trim()
            .to_string();

            HelloResponse {
                message: format!(
                    "Hello, {}! This message was generated on '{}'.",
                    request.name, hostname
                ),
            }
        }
    }
}

fn main() -> ExitCode {
    // This example combines both the server and the client into one binary.
    // This is possible because the server only gets executed if the second
    // argument of the binary invocation is `beyond-server-process`.
    // If this is the case, `Beyond::run_server` will return an `ExitCode`,
    // which should immediately be returned from `main`, as the exit code
    // gets picked up by the client and used to distinguish successes from
    // errors.
    if let Some(exit_code) = beyond_impl::Server::run(beyond_impl::Server) {
        return exit_code;
    }

    // If the program reaches this point, the server did not get executed.
    // This means the client should run.

    // Parse the CLI arguments for the client.
    let name = match std::env::args().nth(2) {
        Some(name) => name,
        None => {
            eprintln!("usage: beyond_example <destination> <name>");
            return ExitCode::FAILURE;
        }
    };
    let destination = std::env::args()
        .nth(1)
        .expect("if element two exists, element one should always exist");

    // Create an instance of the client that was fully generated by `beyond`.
    // It takes the SSH host to connect to and the binary to run on the server
    // as arguments.
    let client = beyond_impl::Client::new(destination, "beyond_example".to_string());

    // Execute one of the functions that was defined on the server.
    // It has the exact same signature, but executes it on the server
    // by invoking the server binary over SSH.
    let response = match client.hello(HelloRequest { name }) {
        Ok(response) => response,
        Err(e) => {
            eprintln!("error: {}", e);
            return ExitCode::FAILURE;
        }
    };
    println!("{}", response.message);

    ExitCode::SUCCESS
}
